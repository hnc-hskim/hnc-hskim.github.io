[
{
	"uri": "https://hnc-hskim.github.io/workshop/ide/vscode/",
	"title": "vscode",
	"tags": [],
	"description": "",
	"content": "VS code extentions  cloude code kubernetes  [참고] https://www.sobyte.net/post/2021-12/deploy-vscode-on-k8s/\n[참고2] https://github.com/coder/coder\n아래 명세서를 파일로 저장후 배포한다. (패스워드및 네임스페이스 확인)  code-server.yaml  apiVersion: v1 kind: Namespace metadata: name: code-server --- apiVersion: v1 kind: Service metadata: name: code-server namespace: code-server spec: ports: - port: 80 targetPort: 8080 selector: app: code-server --- apiVersion: apps/v1 kind: Deployment metadata: labels: app: code-server name: code-server namespace: code-server spec: selector: matchLabels: app: code-server template: metadata: labels: app: code-server spec: containers: - image: codercom/code-server imagePullPolicy: IfNotPresent name: code-server ports: - containerPort: 8080 env: - name: PASSWORD value: \u0026#34;your password\u0026#34; --- apiVersion: extensions/v1beta1 kind: Ingress metadata: name: code-server-ingress namespace: code-server annotations: kubernetes.io/ingress.class: nginx spec: rules: - host: \u0026#34;your_host_name.example.com\u0026#34; http: paths: - backend: serviceName: code-server servicePort: 80 ingress 확인(Host에 접속) kubectl get ingress -n code-server NAME CLASS HOSTS ADDRESS PORTS AGE code-server-ingress \u0026lt;none\u0026gt; code.**********.com a**************1-716630360.ap-northeast-2.elb.amazonaws.com 80 16m 접속 화면 web vs code 화면 sample HTML  Extension을 선택하고 Live Preview 검색후 설치한다.  node.js 설치  터미널을 열고 다음 항목을 붙여 넣는다.  curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs "
},
{
	"uri": "https://hnc-hskim.github.io/workshop/",
	"title": "Workshops",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://hnc-hskim.github.io/hugo/",
	"title": "Hugoes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://hnc-hskim.github.io/hugo/style/",
	"title": "Style",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://hnc-hskim.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Contents  kubernetes  CLI   workshop  MSA    A notice disclaimer\n\rAn information disclaimer\n\rA tip disclaimer\n\rA warning disclaimer\n\r"
},
{
	"uri": "https://hnc-hskim.github.io/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "",
	"content": "CLI 사용법 "
},
{
	"uri": "https://hnc-hskim.github.io/kubernetes/aws-cli/",
	"title": "Aws Cli",
	"tags": [],
	"description": "",
	"content": "aws 계정 정보 조회 aws sts get-caller-identity --profile \u0026#34;name\u0026#34; kubeconfig 등록 aws eks --profile \u0026#34;profile name\u0026#34; update-kubeconfig --name \u0026#34;cluster name\u0026#34; --region ap-northeast-2 "
},
{
	"uri": "https://hnc-hskim.github.io/kubernetes/cli/",
	"title": "Cli",
	"tags": [],
	"description": "",
	"content": "컨텍스트 조회 # 조회 kubectl config get-contexts # 사용 kubectl config use-context \u0026#34;context name\u0026#34; 클러스터명 조회 kubectl config view --minify -o jsonpath=\u0026#39;{.clusters[].name}\u0026#39; 노드에 레이블 추가 # 레이블 추가 kubectl label nodes \u0026lt;your-node-name\u0026gt; disktype=ssd # 레이블 확인 kubectl get nodes --show-labels "
},
{
	"uri": "https://hnc-hskim.github.io/workshop/msa/software-architecture/",
	"title": "Software Architecture",
	"tags": [],
	"description": "",
	"content": "[참고] https://dev.to/zachgoll/introduction-to-software-architecture-monolithic-vs-layered-vs-microservices-452\n[참고] https://github.com/mermaid-js/mermaid\nDiagram Editor\n\u0026ldquo;Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius—and a lot of courage to move in the opposite direction\u0026rdquo;\n[From E.F. Schumacher\u0026rsquo;s book Small is Beautiful]\n\r1. 소프트웨어 아키텍처 소프트웨어 구조 또는 소프트웨어 아키텍처(software architecture)는 소프트웨어의 구성요소들 사이에서 유기적 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙이다.\n1.1 소프트웨어 아키텍처 설계시 고려사항  성능: 회전하는 \u0026ldquo;로드 중\u0026rdquo; 아이콘이 사라지기 전에 얼마나 기다려야 합니까? 가용성: 시스템이 실행되는 시간의 백분율은 무엇입니까? 사용성: 사용자가 시스템의 인터페이스를 쉽게 파악할 수 있습니까? 수정 가능성: 개발자가 시스템에 기능을 추가하려는 경우 수행하기 쉽습니까? 상호 운용성: 시스템이 다른 시스템과 원활하게 작동합니까? 보안: 시스템 주변에 보안 포트리스가 있습니까? 이식성: 시스템이 다양한 플랫폼(예: Windows, Mac, Linux)에서 실행될 수 있습니까? 확장성: 사용자 기반을 빠르게 성장시키면 시스템이 새로운 트래픽을 충족하도록 쉽게 확장할 수 있습니까? 배포 가능성: 프로덕션 환경에 새로운 기능을 추가하는 것이 쉽습니까? 안전: 소프트웨어가 물리적 사물을 제어하는 ​​경우 실제 사람에게 위험합니까?  2. 소프트웨어 아키텍처가 프로젝트의 성공에 중요한 13가지 이유 원문\r번역\r\r1. An architecture will inhibit or enable a system’s driving quality attributes. 2. The decisions made in an architecture allow you to reason about and manage change as the system evolves. 3. The analysis of an architecture enables early prediction of a system’s qualities. 4. A documented architecture enhances communication among stakeholders. 5. The architecture is a carrier of the earliest and hence most fundamental, hardest-to-change design decisions. 6. An architecture defines a set of constraints on subsequent implementation. 7. The architecture dictates the structure of an organization, or vice versa. 8. An architecture can provide the basis for evolutionary prototyping. 9. An architecture is the key artifact that allows the architect and project manager to reason about cost and schedule. 10. An architecture can be created as a transferable, reusable model that forms the heart of a product line. 11. Architecture-based development focuses attention on the assembly of components, rather than simply on their creation. 12. By restricting design alternatives, architecture channels the creativity of developers, reducing design and system complexity. 13. An architecture can be the foundation for training a new team member \r\r1. 아키텍처는 시스템의 구동 품질 속성을 억제하거나 활성화합니다. 2. 아키텍처에서 내린 결정을 통해 시스템이 발전함에 따라 변경 사항을 추론하고 관리할 수 있습니다. 3. 아키텍처 분석을 통해 시스템 품질을 조기에 예측할 수 있습니다. 4. 문서화된 아키텍처는 이해 관계자 간의 의사 소통을 향상시킵니다. 5. 아키텍처는 가장 초기에 가장 기본적이고 가장 변경하기 어려운 설계 결정의 전달자입니다. 6. 아키텍처는 후속 구현에 대한 일련의 제약 조건을 정의합니다. 7. 아키텍처는 조직의 구조를 결정하거나 그 반대의 경우도 마찬가지입니다. 8. 아키텍처는 진화적 프로토타이핑의 기초를 제공할 수 있습니다. 9. 아키텍처는 건축가와 프로젝트 관리자가 비용과 일정에 대해 추론할 수 있도록 하는 핵심 아티팩트입니다. 10. 아키텍처는 제품 라인의 핵심을 형성하는 양도 가능하고 재사용 가능한 모델로 생성될 수 있습니다. 11. 아키텍처 기반 개발은 단순히 구성 요소를 만드는 것보다 구성 요소의 조립에 주의를 집중합니다. 12. 설계 대안을 제한함으로써 아키텍처는 개발자의 창의성을 전달하여 설계 및 시스템 복잡성을 줄입니다. 13. 아키텍처는 새로운 팀원을 교육하기 위한 기반이 될 수 있습니다. \r\r\r\r\r"
},
{
	"uri": "https://hnc-hskim.github.io/workshop/msa/",
	"title": "Msa",
	"tags": [],
	"description": "",
	"content": "[netflex microservice] https://netflixtechblog.com/tagged/microservices\n마이크로서비스는 소프트웨어가 잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식입니다.\n이러한 서비스는 독립적인 소규모 팀에서 보유합니다. 마이크로서비스 아키텍처는 애플리케이션의 확장을 용이하게 하고 개발 속도를 앞당겨 혁신을 실현하고 새로운 기능의 출시 시간을 단축할 수 있게 해 줍니다.\n\rGoals  소프트웨어 아키텍처가 필요한 이유 모놀리식 아키텍처 계층화된 아키텍처 마이크로 서비스 아키텍처  마이크로서비스 아키텍처의 경우, 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행됩니다. 이러한 서비스는 경량 API를 사용하여 잘 정의된 인터페이스를 통해 통신합니다. 서비스는 비즈니스 기능을 위해 구축되며 서비스마다 한 가지 기능을 수행합니다. 서비스가 독립적으로 실행되기 때문에 애플리케이션의 특정 기능에 대한 수요를 충족하도록 각각의 서비스를 업데이트, 배포 및 확장할 수 있습니다.\n[출처] https://aws.amazon.com/ko/microservices/\nbluewhale-users\n"
},
{
	"uri": "https://hnc-hskim.github.io/workshop/msa/concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "\r아래에 사용된 예제는 NodeJS, ExpressJS, MongoDB를 이용하여 구성되었습니다.\n\rDiagram Editor\nmermaid flowchart syntax\n1. 모놀리식 아키텍처 VS 마이크로서비스 아키텍처 Monolithic Architecture 전통적인 모놀로식 아키텍처가 비효율적으로 보일 수 있지만 실제로 개발중인 애플리케이션이 충분히 복잡하지 않다면 마이크로서비스 아키텍처의 이점을 확인하기는 쉽지 않다. 비교적 간단한 아키텍처의 경우 충분히 활용 가능한 솔루션이라고 할 수 있다.\n따라서 모놀로딕 아키텍처로 시작하여 마이크로 서비스 아키텍처로 리팩토링하는것이 효율적인 개발 방법일수도 있다.\n장점  손쉬운 배포 : 단일 실행파일 또는 디렉토리로 작성되어 배포가 쉽다. 개발 : 단일 코드베이스로 구성되어 애플리케이션 개발이 쉽다. 성능 : 단일 API를 사용하여 마이크로서비스의 여러 API가 수행하는 결과와 동일한 기능을 수행한다. 테스트 간소화 : 중앙집중식 구성으로 분산된 환경보다 End-TO-End 테스트를 더 빠르게 수행할 수 있다. 디버깅 : 모든 코드가 한곳에 있으므로 요청을 트랙킹해 문제를 찾기 더 쉽다.  애플리케이션 구조 아래의 코드를 통해 monolithic 구조를 살펴보자.(계층으로 분리되지 않은 단일 구성을 설명하기 위한 예제이다. 즉, 모든 구성요소가 하나의 코드베이스로 묶인 아키텍처이다. )\n[monolithic architecture example github] https://github.com/zachgoll/monolithic-architecture-example-app\n이 코드에서 확인 가능한것은 애플리케이션간의 구분이 없다는것이다. app.js에서 데이터베이스, 서버 및 API 엔드포인트에 대한 연결을 확인할 수 있다.\nconst express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const bodyParser = require(\u0026#34;body-parser\u0026#34;);  // This will allow our presentation layer to retrieve data from this API without // running into cross-origin issues (CORS) app.use(cors()); app.use(bodyParser.json());  // ============================================ // ========== DATABASE CONNECTION =========== // ============================================ // Connect to running database mongoose.connect(  `mongodb://${process.env.DB_USER}:${process.env.DB_PW}@127.0.0.1:27017/monolithic_app_db`,  { useNewUrlParser: true } );  // User schema for mongodb const UserSchema = mongoose.Schema(  {  name: { type: String },  email: { type: String },  },  { collection: \u0026#34;users\u0026#34; } );  // Define the mongoose model for use below in method const User = mongoose.model(\u0026#34;User\u0026#34;, UserSchema);  function getUserByEmail(email, callback) {  try {  User.findOne({ email: email }, callback);  } catch (err) {  callback(err);  } }  // set the view engine to ejs app.set(\u0026#34;view engine\u0026#34;, \u0026#34;ejs\u0026#34;);  // index page app.get(\u0026#34;/\u0026#34;, function (req, res) {  res.render(\u0026#34;home\u0026#34;); });  // ============================================ // ============ API ENDPOINT ================ // ============================================ app.post(\u0026#34;/register\u0026#34;, function (req, res) {  const newUser = new User({  name: req.body.name,  email: req.body.email,  });   newUser.save((err, user) =\u0026gt; {  res.status(200).json(user);  }); });  // ============================================ // ============== SERVER ===================== // ============================================ app.listen(8080); console.log(\u0026#34;Visit app at http://localhost:8080\u0026#34;); 이 모놀리딕 애플리케이션이 확장하기 시작할 경우 빠르게 코드는 엉망이 될 것이다. 이 단계에서 대부분 마이크로서비스 아키텍처로의 전환을 선택하지만, 리팩토링을 통하여 계층화된 아키텍처로 바꾸는것을 다른 하나의 옵션으로 고민해 볼 수 있다.\nMonolithic Architecture (with better \u0026ldquo;layered\u0026rdquo; or \u0026ldquo;n-tier\u0026rdquo; design) 계층화된 아키텍처는 애플리케이션을 일반적으로 다음과 같은 레이어들로 분할할 수 있다.\n 프리젠테이션 계층(Presentation Layer) 비지니스 계층(Business Layer) 데이터 액세스 계층(Data Access Layer)  다른 형태로 다음과 같은 레이어로 분류할 수도 있다.\n Presentation Layer Application Layer Domain Layer Persistence Layer  Layered Architecture Diagram flowchart TD subgraph Layered-Architecture subgraph Presentation-Layer direction LR Angular --- A{{Closed}} end subgraph Business-Layer direction LR Express --- B{{Closed}} end subgraph Shared-Utilities-Layer direction LR String-Utilities --- Object-Transformation-Utilities --- C{{Closed}} end subgraph Data-Layer direction LR Mongo --- D{{Closed}} end end Presentation-Layer -- Business-Layer Business-Layer -- Shared-Utilities-Layer Shared-Utilities-Layer -- Data-Layer \r중요한 점은 각 레이어 구조에서 바로 아래 레이어만 사용할 수 있게 하도록 구조를 분리하는것입니다. 하지만 Utility 레이어의 경우처럼 때로는 공유하여 쓸수 있는 레이어가 필요할 수도 있습니다. 다이어그램에서 모든 레이어에서 사용할 수 있도록 열린 레이어로 생성한것을 확인할 수 있습니다.\nApplication Structure 위에서 언급한대로 계층화된 아키텍처에서는 각 계층이 바로 아래 계층만 사용할수 있다는 규칙이 있습니다. 그럼 이 중요한 규칙을 기반으로 monolothic archicture를 변경해 보겠습니다.\n 프레젠테이션 계층은 HTML 사용자 양식에서 호출합니다. 프레젠테이션 계층 자바스크립트는 양식을 처리하고 비즈니스 계층에 대한 호출을 실행합니다. 비즈니스 계층은 양식 정보를 처리하고 데이터 액세스 계층을 호출합니다. 데이터 액세스 계층은 정보를 처리하고 사용자를 위해 데이터베이스에 쿼리합니다. 데이터 액세스 계층은 비즈니스 계층에 정보를 반환합니다. 비즈니스 계층은 HTTP를 통해 프레젠테이션 계층에 정보를 반환합니다. 프레젠테이션 레이어는 새로운 정보로 뷰를 렌더링합니다.  1. 프레젠테이션 계층은 HTML 사용자 양식에서 호출합니다. \u0026lt;!-- File: home.ejs --\u0026gt;  \u0026lt;!-- On form submit, home.ejs executes the getDataFromBusinessLayer() function --\u0026gt;  \u0026lt;form id=\u0026#34;emailform\u0026#34; onsubmit=\u0026#34;getDataFromBusinessLayer()\u0026#34;\u0026gt;  \u0026lt;input name=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; placeholder=\u0026#34;Enter email...\u0026#34; /\u0026gt;  \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Load Profile\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 2. 프리젠테이션 계층 자바스크립트는 양식을 처리하고 비즈니스 계층에 대한 호출을 실행합니다. // File: presentation-layer-user.js  function getDataFromBusinessLayer() {  event.preventDefault();  const email = $(\u0026#34;#email\u0026#34;).val();   // Perform the GET request to the business layer  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  $.ajax({  url: `http://localhost:8081/get-user/${email}`,  type: \u0026#34;GET\u0026#34;,  success: function (user) {  // Render the user object on the page  // Ommitted for brevity  },  error: function (jqXHR, textStatus, ex) {  console.log(textStatus + \u0026#34;,\u0026#34; + ex + \u0026#34;,\u0026#34; + jqXHR.responseText);  },  }); } 비즈니스 계층은 양식 정보를 처리하고 데이터 액세스 계층을 호출합니다.  // File: business-layer-user.js  app.get(\u0026#34;/get-user/:useremail\u0026#34;, function (req, res) {  // Makes a call to the data access layer  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  const user = User.getUserByEmail(req.params.useremail, (error, user) =\u0026gt; {  res.status(200).json({  name: user.name,  email: user.email,  profileUrl: user.profileUrl,  });  }); }); 데이터 접근 계층은 정보를 처리하고 사용자를 위해 데이터베이스에 쿼리합니다.  // File: data-layer-user.js  module.exports.getUserByEmail = (email, callback) =\u0026gt; {  try {  // Makes a call to the database  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  User.findOne({ email: email }, callback);  } catch (err) {  callback(err);  } };  데이터 액세스 계층은 비즈니스 계층에 정보를 반환합니다.\n  비즈니스 계층은 HTTP를 통해 프레젠테이션 계층에 정보를 반환합니다.\n  프레젠테이션 레이어는 새로운 정보로 뷰를 렌더링합니다.\n  각 단계를 통해 계층이 담당하는 구체적인 의무를\n[monolithic layered architecture example github] https://github.com/zachgoll/layered-architecture-example-app\n"
},
{
	"uri": "https://hnc-hskim.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://hnc-hskim.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]