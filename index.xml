<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://hnc-hskim.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 13 Jul 2022 09:00:36 +0900</lastBuildDate><atom:link href="https://hnc-hskim.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Software Architecture Pattern</title>
      <link>https://hnc-hskim.github.io/workshop/msa/software-architecture-pattern/</link>
      <pubDate>Mon, 18 Jul 2022 16:48:39 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/workshop/msa/software-architecture-pattern/</guid>
      <description>[참고] https://towardsdatascience.com/10-common-software-architectural-patterns-in-a-nutshell-a0b47a1e9013
[Architectural patterns] https://www.ou.nl/documents/40554/791670/IM0203_03.pdf/30dae517-691e-b3c7-22ed-a55ad27726d6
10가지 소프트웨어 아키텍처 패턴  계층화 패턴 (Layered pattern) 클라이언트-서버 패턴 (Client-server pattern) 마스터-슬레이브 패턴 (Master-slave pattern) 파이프-필터 패턴 (Pipe-filter pattern) 브로커 패턴 (Broker pattern) 피어 투 피어 패턴 (Peer-to-peer pattern) 이벤트-버스 패턴 (Event-bus pattern) 모델-뷰-컨트롤러 패턴 (Model-view-controller pattern) 블랙보드 패턴 (Blackboard pattern) 인터프리터 패턴 (Interpreter pattern)  1. 계층화 패턴 (Layered pattern) 계층화 패턴에서 흔히 볼 수 있는 4개의 계층은 다음과 같다.
 프레젠테이션 계층 ( UI 계층 이라고도 함 ) 애플리케이션 계층 ( 서비스 계층 이라고도 함 ) 비즈니스 논리 계층 ( 도메인 계층 이라고도 함 ) 데이터 액세스 계층 ( 지속성 계층 이라고도 함 )  (1) 일반 데스크탑 애플리케이션</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://hnc-hskim.github.io/terraform/introduction/</link>
      <pubDate>Mon, 18 Jul 2022 14:19:28 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/terraform/introduction/</guid>
      <description>테라폼(Terraform)은 하시코프(Hashicorp)에서 오픈소스로 개발중인 클라우드 인프라스트럭처 자동화를 지향하는 코드로서의 인프라스트럭처(Infrastructure as Code), IaC1 도구입니다.
AWS 클라우드 포메이션AWS CloudFormation의 경우 AWS만 지원하는 것과 달리 테라폼의 경우 아마존 웹 서비스, 구글 클라우드 플랫폼(Google Cloud Platform), 마이크로소프트 애저(Microsoft Azure)와 같은 주요 클라우드 서비스를 비롯한 다양한 클라우드 서비스들을 프로바이더 방식으로 제공하고 있습니다. 이를 통해 테라폼만으로 멀티 클라우드의 리소스들을 선언하고 코드로 관리하는 것도 가능합니다.
테라폼은 고(Go) 프로그래밍 언어로 개발 되고 있습니다.
테라폼 공식 홈
  IaC는 코드로 인프라스트럭처를 관리한다는 개념으로 테라폼에서는 하시코프 설정 언어(HCL, Hashicorp Configuration Language)을 사용해 클라우드 리소스를 선언합니다.</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://hnc-hskim.github.io/references/kubernetes/</link>
      <pubDate>Mon, 18 Jul 2022 13:58:17 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/references/kubernetes/</guid>
      <description>참고  Advanced Scheduling  </description>
    </item>
    
    <item>
      <title>Terraform</title>
      <link>https://hnc-hskim.github.io/references/terraform/</link>
      <pubDate>Fri, 15 Jul 2022 13:52:27 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/references/terraform/</guid>
      <description>참고  helm values파일내 환경변수 전달 nginx controller acm 적용  </description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>https://hnc-hskim.github.io/hugo/comments/</link>
      <pubDate>Fri, 15 Jul 2022 11:57:37 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/hugo/comments/</guid>
      <description>[참고] https://velog.io/@mellonggo/Github-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-Hugo
댓글 기능 추가  리파지터리 생성  blog-comments로 리파지터리 생성  layouts/partials/custom-footer.html 파일 생성 및 스크립트 추가  테마별로 지정해야할 위치가 다를수 있다. learn 테마의 경우 post 레이아웃을 찾을수 없어 custom-footer.html에 추가한다.
 아래 코드를 복하하여 custom-footer.html에 붙여넣는다.  &amp;lt;script src=&amp;#34;https://utteranc.es/client.js&amp;#34; repo=&amp;#34;user id/blog-comments&amp;#34; issue-term=&amp;#34;title&amp;#34; theme=&amp;#34;github-light&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34; async&amp;gt; &amp;lt;/script&amp;gt; 첫 로딩시 댓글 기능은 비활성화되어 있고 github 로그인 인증을 통해 해당 리파지터리에서 utterances app 사용을 승인하면 이후 댓글 기능을 사용할 수 있다.</description>
    </item>
    
    <item>
      <title>Scheduling</title>
      <link>https://hnc-hskim.github.io/cloud/operation/scheduling/</link>
      <pubDate>Fri, 15 Jul 2022 08:52:22 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/cloud/operation/scheduling/</guid>
      <description>노드에 파드 할당하기 특정한 노드(들) 집합에서만 동작하도록 파드를 제한할 수 있다. 이를 수행하는 방법에는 여러 가지가 있으며 권장되는 접근 방식은 모두 레이블 셀렉터를 사용하여 선택을 용이하게 한다. 보통은 스케줄러가 자동으로 합리적인 배치(예: 자원이 부족한 노드에 파드를 배치하지 않도록 노드 간에 파드를 분배)를 수행하기에 이러한 제약 조건은 필요하지 않다. 그러나, 예를 들어 SSD가 장착된 머신에 파드가 배포되도록 하거나 또는 많은 통신을 하는 두 개의 서로 다른 서비스의 파드를 동일한 가용성 영역(availability zone)에 배치하는 경우와 같이, 파드가 어느 노드에 배포될지를 제어해야 하는 경우도 있다.</description>
    </item>
    
    <item>
      <title>vscode</title>
      <link>https://hnc-hskim.github.io/workshop/ide/vscode/</link>
      <pubDate>Wed, 13 Jul 2022 11:12:30 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/workshop/ide/vscode/</guid>
      <description>code server를 활용한 실습 환경 구성이 가능한지 검증해보자.
VS code extentions  cloud code kubernetes  [참고] https://www.sobyte.net/post/2021-12/deploy-vscode-on-k8s/
[참고2] https://github.com/coder/coder
아래 명세서를 파일로 저장후 배포한다. (패스워드및 네임스페이스 확인)  code-server.yaml  apiVersion: v1 kind: Namespace metadata: name: code-server --- apiVersion: v1 kind: Service metadata: name: code-server namespace: code-server spec: ports: - port: 80 targetPort: 8080 selector: app: code-server --- apiVersion: apps/v1 kind: Deployment metadata: labels: app: code-server name: code-server namespace: code-server spec: selector: matchLabels: app: code-server template: metadata: labels: app: code-server spec: containers: - image: codercom/code-server imagePullPolicy: IfNotPresent name: code-server ports: - containerPort: 8080 env: - name: PASSWORD value: &amp;#34;your password&amp;#34; --- apiVersion: extensions/v1beta1 kind: Ingress metadata: name: code-server-ingress namespace: code-server annotations: kubernetes.</description>
    </item>
    
    <item>
      <title>Style</title>
      <link>https://hnc-hskim.github.io/hugo/style/</link>
      <pubDate>Wed, 13 Jul 2022 09:06:26 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/hugo/style/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Aws Cli</title>
      <link>https://hnc-hskim.github.io/kubernetes/aws-cli/</link>
      <pubDate>Wed, 13 Jul 2022 08:52:53 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/kubernetes/aws-cli/</guid>
      <description>aws 계정 정보 조회 aws sts get-caller-identity --profile &amp;#34;name&amp;#34; kubeconfig 등록 aws eks --profile &amp;#34;profile name&amp;#34; update-kubeconfig --name &amp;#34;cluster name&amp;#34; --region ap-northeast-2 </description>
    </item>
    
    <item>
      <title>Cli</title>
      <link>https://hnc-hskim.github.io/kubernetes/cli/</link>
      <pubDate>Wed, 13 Jul 2022 08:51:28 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/kubernetes/cli/</guid>
      <description>컨텍스트 조회 # 조회 kubectl config get-contexts # 사용 kubectl config use-context &amp;#34;context name&amp;#34; 클러스터명 조회 kubectl config view --minify -o jsonpath=&amp;#39;{.clusters[].name}&amp;#39; 노드에 레이블 추가 # 레이블 추가 kubectl label nodes &amp;lt;your-node-name&amp;gt; disktype=ssd # 레이블 확인 kubectl get nodes --show-labels </description>
    </item>
    
    <item>
      <title>Software Architecture</title>
      <link>https://hnc-hskim.github.io/workshop/msa/software-architecture/</link>
      <pubDate>Tue, 12 Jul 2022 15:43:56 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/workshop/msa/software-architecture/</guid>
      <description>[참고] https://dev.to/zachgoll/introduction-to-software-architecture-monolithic-vs-layered-vs-microservices-452
[참고] https://github.com/mermaid-js/mermaid
Diagram Editor
&amp;ldquo;Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius—and a lot of courage to move in the opposite direction&amp;rdquo;
[From E.F. Schumacher&amp;rsquo;s book Small is Beautiful]
1. 소프트웨어 아키텍처 소프트웨어 구조 또는 소프트웨어 아키텍처(software architecture)는 소프트웨어의 구성요소들 사이에서 유기적 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙이다.
1.1 소프트웨어 아키텍처 설계시 고려사항  성능: 회전하는 &amp;ldquo;로드 중&amp;rdquo; 아이콘이 사라지기 전에 얼마나 기다려야 합니까?</description>
    </item>
    
    <item>
      <title>Concept</title>
      <link>https://hnc-hskim.github.io/workshop/msa/concept/</link>
      <pubDate>Tue, 12 Jul 2022 13:38:23 +0900</pubDate>
      
      <guid>https://hnc-hskim.github.io/workshop/msa/concept/</guid>
      <description>아래에 사용된 예제는 NodeJS, ExpressJS, MongoDB를 이용하여 구성되었습니다.
Diagram Editor
mermaid flowchart syntax
1. 모놀리식 아키텍처 VS 마이크로서비스 아키텍처 Monolithic Architecture 전통적인 모놀로식 아키텍처가 비효율적으로 보일 수 있지만 실제로 개발중인 애플리케이션이 충분히 복잡하지 않다면 마이크로서비스 아키텍처의 이점을 확인하기는 쉽지 않다. 비교적 간단한 아키텍처의 경우 충분히 활용 가능한 솔루션이라고 할 수 있다.
따라서 모놀로딕 아키텍처로 시작하여 마이크로 서비스 아키텍처로 리팩토링하는것이 효율적인 개발 방법일수도 있다.
장점  손쉬운 배포 : 단일 실행파일 또는 디렉토리로 작성되어 배포가 쉽다.</description>
    </item>
    
  </channel>
</rss>
